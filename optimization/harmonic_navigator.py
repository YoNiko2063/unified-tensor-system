"""
HarmonicNavigator — navigate Koopman space via harmonic structure.

Core idea
---------
Starting from a known **abelian region** (the linear resonant frequency ω₀ of
any second-order system), navigate through nonlinear Koopman regions by tracking
*harmonic structure* — integer ratios between eigenvalues.

Why this works
--------------
For any periodic orbit, the Koopman spectrum contains the fundamental frequency
ω₀_eff and its harmonics {nω₀_eff : n ∈ ℤ}.  An *abelian region* is a Koopman
regime where eigenvalues form exact integer ratios — the group generated by
exp(inω₀_eff·t) is a 1-D torus U(1), which is abelian (commutative).

Navigation algorithm
--------------------
1. Start at ω₀_linear (known exactly from the analytic formula of any linear system).
2. Sweep amplitude/energy levels → EDMD extracts ω₀_eff(E) at each level.
3. Measure DissonanceMetric(ω₀_eff, ω₀_linear): distance from perfect harmonic ratio.
4. Regions where dissonance < threshold are abelian *landing zones*.
5. Build HarmonicPath: the path in (log_ω₀_eff, log_E) space.

Cross-domain geometric patterns
--------------------------------
The SHAPE of the ω₀_eff(E) curve is universal for all systems with the same
normalised nonlinearity β/α.  Comparing curvature profiles across domains reveals
that the same integer-ratio harmonic structure appears in:

  Electrical oscillators (RLC with nonlinear inductor)
  Mechanical oscillators (spring-mass with cubic stiffness / Duffing)
  Optimisation algorithms (GD on quartic losses)
  Biological rhythms, musical intervals, crystallography, ...

The **abelian landing zones** are the mathematical expression of why 1:2:3
harmonic ratios (octave, fifth, ...) are universal across disciplines: they mark
the geometric attractors in Koopman regime space.

Energy-conditional retrieval
-----------------------------
retrieve_near_abelian(memory, omega0, log_E, window) returns KoopmanExperience
entries that match BOTH the 3D invariant (existing mechanism) AND log_E ± window.
This prevents linear-regime memory from warm-starting high-energy nonlinear search.
"""

from __future__ import annotations

import math
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple

import numpy as np

from tensor.spectral_path import DissonanceMetric
from optimization.koopman_memory import KoopmanExperienceMemory
from optimization.koopman_signature import (
    KoopmanInvariantDescriptor,
    compute_invariants,
    _LOG_OMEGA0_SCALE,
)
from tensor.koopman_edmd import KoopmanResult
from optimization.duffing_evaluator import DuffingEvaluator, DuffingResult


# ── Data structures ───────────────────────────────────────────────────────────


@dataclass
class AbelianRegion:
    """
    A Koopman regime where eigenvalue algebra is approximately abelian.

    An abelian region is characterised by:
      - Low DissonanceMetric(ω₀_eff, ω₀_linear): eigenvalues are near integer
        multiples of the fundamental frequency.
      - Small commutator norm (when measured via LCAPatchDetector).

    The region is defined by its position in (ω₀_eff, log_E) space.
    """

    omega0_eff: float          # effective frequency extracted from Koopman [rad/s]
    Q_eff: float               # effective quality factor
    log_E: float               # log₁₀(normalised energy) at this region
    omega0_linear: float       # reference ω₀ (linear limit of the source system)
    dissonance: float          # DissonanceMetric(ω₀_eff, ω₀_linear)
    harmonic_ratio: float      # nearest integer n s.t. ω₀_eff ≈ n·ω₀_linear
    is_abelian: bool           # dissonance < threshold
    domain: str                # "duffing_α1.0", "rlc", "spring_mass", etc.
    amplitude: float           # initial displacement that produced this region
    eigenvalues: Optional[np.ndarray] = field(default=None, repr=False)

    def omega0_ratio(self) -> float:
        """ω₀_eff / ω₀_linear — how far from fundamental."""
        return self.omega0_eff / max(self.omega0_linear, 1e-30)


@dataclass
class HarmonicPath:
    """
    Path through Koopman space from linear ω₀ to higher energy regimes.

    Ordered sequence of AbelianRegion snapshots as energy increases.
    The curvature profile encodes the rate of frequency shift with energy —
    this is the *universal geometric signature* that appears across domains.
    """

    regions: List[AbelianRegion]
    omega0_linear: float            # starting linear resonance [rad/s]
    curvature_profile: np.ndarray   # d(log(ω₀_eff/ω₀_linear)) / d(log_E)
    abelian_landing_indices: List[int]   # indices where dissonance < threshold
    domain: str

    def is_flat(self, tol: float = 0.01) -> bool:
        """True if curvature ≈ 0 everywhere (linear regime — β=0)."""
        if len(self.curvature_profile) == 0:
            return True
        return float(np.max(np.abs(self.curvature_profile))) < tol

    def mean_curvature(self) -> float:
        """Average curvature — encodes nonlinearity strength."""
        if len(self.curvature_profile) == 0:
            return 0.0
        return float(np.mean(self.curvature_profile))

    def geometric_signature(self, n_bins: int = 10) -> np.ndarray:
        """
        Normalised curvature profile resampled to n_bins — domain-invariant shape.

        Two paths with identical geometry (same β/α ratio) will have cosine
        similarity ≈ 1.0 via this signature.
        """
        c = self.curvature_profile
        if len(c) == 0:
            return np.zeros(n_bins)
        x_orig = np.linspace(0, 1, len(c))
        x_new = np.linspace(0, 1, n_bins)
        sig = np.interp(x_new, x_orig, c)
        norm = np.linalg.norm(sig)
        return sig / max(norm, 1e-12)


# ── Navigator ─────────────────────────────────────────────────────────────────


class HarmonicNavigator:
    """
    Navigate Koopman space from a known linear resonance ω₀_linear.

    Uses DissonanceMetric to detect abelian landing zones (harmonic integer ratios).
    Builds paths whose curvature profile encodes the universal geometric signature.

    Args:
        omega0_linear:      linear resonant frequency [rad/s or rad/step] of source
        abelian_threshold:  DissonanceMetric < this → classify as abelian  (default 0.05)
        dissonance_K:       max p/q ratio searched by DissonanceMetric (default 10)
    """

    def __init__(
        self,
        omega0_linear: float,
        abelian_threshold: float = 0.05,
        dissonance_K: int = 10,
    ) -> None:
        self.omega0_linear = float(omega0_linear)
        self.abelian_threshold = float(abelian_threshold)
        self._dissonance = DissonanceMetric(K=dissonance_K)

    # ── Sweep ─────────────────────────────────────────────────────────────────

    def sweep_energy(
        self,
        evaluator: DuffingEvaluator,
        amplitudes: np.ndarray,
    ) -> List[AbelianRegion]:
        """
        Sweep across amplitude levels.  For each amplitude:
          1. Simulate Duffing from (x₀=A, v₀=0).
          2. Extract (ω₀_eff, Q_eff, log_E) via EDMD.
          3. Compute DissonanceMetric(ω₀_eff, ω₀_linear).
          4. Classify as abelian if dissonance < threshold.

        Returns ordered list of AbelianRegions (sorted by log_E ascending).
        """
        regions: List[AbelianRegion] = []
        omega0_lin = self.omega0_linear

        for A in amplitudes:
            result: DuffingResult = evaluator.evaluate(x0=float(A), v0=0.0)
            diss = self._dissonance.compute(result.omega0_eff, omega0_lin)

            ratio = result.omega0_eff / max(omega0_lin, 1e-30)
            nearest_n = round(ratio)
            nearest_n = max(nearest_n, 1)  # always ≥ 1

            region = AbelianRegion(
                omega0_eff=result.omega0_eff,
                Q_eff=result.Q_eff,
                log_E=result.log_E,
                omega0_linear=omega0_lin,
                dissonance=float(diss),
                harmonic_ratio=float(nearest_n),
                is_abelian=(float(diss) < self.abelian_threshold),
                domain=f"duffing_α{evaluator.params.alpha:.2f}",
                amplitude=float(A),
                eigenvalues=result.eigenvalues,
            )
            regions.append(region)

        # Sort by energy ascending
        regions.sort(key=lambda r: r.log_E)
        return regions

    # ── Path building ─────────────────────────────────────────────────────────

    def build_path(
        self, regions: List[AbelianRegion], domain: str = "duffing"
    ) -> HarmonicPath:
        """
        Build HarmonicPath from a list of AbelianRegions.

        Curvature at step i = d(log(ω₀_eff/ω₀_linear)) / d(log_E).
        Flat curvature (≈ 0) signals linear regime (β=0).
        Positive curvature signals hardening spring.
        """
        if len(regions) < 2:
            return HarmonicPath(
                regions=regions,
                omega0_linear=self.omega0_linear,
                curvature_profile=np.array([]),
                abelian_landing_indices=[0] if regions else [],
                domain=domain,
            )

        log_E = np.array([r.log_E for r in regions])
        log_ratio = np.array([
            math.log(max(r.omega0_ratio(), 1e-30))
            for r in regions
        ])

        d_log_ratio = np.diff(log_ratio)
        d_log_E = np.diff(log_E)
        # Avoid division by near-zero — treat flat energy as near-constant ratio
        curvature = d_log_ratio / np.where(np.abs(d_log_E) > 1e-9, d_log_E, 1e-9)

        landings = [
            i for i, r in enumerate(regions)
            if r.is_abelian
        ]

        return HarmonicPath(
            regions=regions,
            omega0_linear=self.omega0_linear,
            curvature_profile=curvature,
            abelian_landing_indices=landings,
            domain=domain,
        )

    # ── Cross-domain comparison ───────────────────────────────────────────────

    def compare_paths(
        self, path_a: HarmonicPath, path_b: HarmonicPath, n_bins: int = 10,
        flat_tol: float = 0.05,
    ) -> float:
        """
        Geometric similarity between two paths via normalised curvature signatures.

        Returns cosine similarity ∈ [-1, 1]; ≈ 1 means identical geometry.

        Special case: if BOTH paths are flat (β=0 → constant ω₀), their
        curvature profiles are near-zero and normalization is unstable. In this
        case we return 1.0 — two linear systems share the same (trivial) geometry.

        Two systems with the same normalised nonlinearity β/α (regardless of
        physical domain) will return similarity ≈ 1.  Linear systems (β=0)
        will have near-zero curvature and similarity ≈ 1 to each other.
        """
        # Flat paths: β=0 → both have trivially zero curvature → same geometry
        if path_a.is_flat(tol=flat_tol) and path_b.is_flat(tol=flat_tol):
            return 1.0

        sig_a = path_a.geometric_signature(n_bins)
        sig_b = path_b.geometric_signature(n_bins)

        if np.linalg.norm(sig_a) < 1e-10 or np.linalg.norm(sig_b) < 1e-10:
            # One flat, one nonlinear → different geometry
            return 0.0

        return float(np.dot(sig_a, sig_b))   # already normalised

    def find_universal_patterns(
        self,
        paths_by_domain: Dict[str, HarmonicPath],
        n_bins: int = 10,
    ) -> Dict[str, object]:
        """
        Compare geometric signatures across all domain pairs.

        Returns:
            {
              "similarities": {domain_pair: cosine_similarity},
              "universal_pattern_detected": bool,
              "universal_threshold": float,
            }

        A universal pattern is detected if ALL pairs have similarity > 0.7.
        """
        domains = list(paths_by_domain.keys())
        similarities: Dict[str, float] = {}

        for i, d1 in enumerate(domains):
            for j, d2 in enumerate(domains):
                if i >= j:
                    continue
                sim = self.compare_paths(
                    paths_by_domain[d1], paths_by_domain[d2], n_bins
                )
                similarities[f"{d1}_vs_{d2}"] = float(sim)

        universal = len(similarities) > 0 and all(
            v > 0.7 for v in similarities.values()
        )

        return {
            "similarities": similarities,
            "universal_pattern_detected": universal,
            "universal_threshold": 0.7,
        }

    # ── Cross-domain memory retrieval ─────────────────────────────────────────

    def retrieve_near_abelian(
        self,
        memory: KoopmanExperienceMemory,
        query_omega0: float,
        query_log_E: float,
        log_E_window: float = 0.5,
        top_n: int = 5,
    ) -> list:
        """
        Energy-conditional cross-domain retrieval.

        Stage 1: retrieve top_n × 3 candidates from shared 3D invariant space.
        Stage 2: filter to entries where |log_E_stored − query_log_E| < log_E_window.

        This prevents low-energy (linear) memory from warm-starting high-energy
        (nonlinear) search, and vice versa.

        Returns filtered list of _MemoryEntry objects.
        """
        # Build a synthetic invariant for querying the 3D space
        log_omega0_norm = float(np.clip(
            (math.log(max(query_omega0, 1e-30)) - math.log(2.0 * math.pi * 1000))
            / math.log(10),
            -3.0, 3.0,
        ))

        # Dummy KoopmanResult for compute_invariants
        dummy_lam = np.array([0.5 + 0.0j])
        query_inv = compute_invariants(
            eigenvalues=dummy_lam,
            eigenvectors=np.array([[1.0]]),
            operator_types=["query"],
            k=1,
            log_omega0_norm=log_omega0_norm,
            log_Q_norm=0.0,
            damping_ratio=0.5,
        )

        candidates = memory.retrieve_candidates(query_inv, top_n=top_n * 3)

        # Energy filter
        filtered = []
        for entry in candidates:
            stored_log_E = float(
                entry.experience.best_params.get("log_E", 0.0)
            )
            if abs(stored_log_E - query_log_E) <= log_E_window:
                filtered.append(entry)
            if len(filtered) >= top_n:
                break

        return filtered

    # ── Analytic helpers ──────────────────────────────────────────────────────

    @staticmethod
    def analytic_omega0_shift(
        alpha: float, beta: float, amplitude: float
    ) -> float:
        """
        First-order analytic frequency shift for Duffing hardening spring.

        ω₀_eff ≈ ω₀_linear · √(1 + 3β·A²/(4α))

        Valid for β·A²/α << 1.  Returns (ω₀_eff - ω₀_linear) / ω₀_linear.
        """
        omega0_lin = math.sqrt(max(alpha, 1e-30))
        omega0_eff = omega0_lin * math.sqrt(
            max(1.0 + 3.0 * beta * amplitude ** 2 / (4.0 * alpha), 1e-30)
        )
        return (omega0_eff - omega0_lin) / max(omega0_lin, 1e-30)

    @staticmethod
    def normalised_beta(alpha: float, beta: float) -> float:
        """β/α — normalised nonlinearity.  Universal geometry parameter."""
        return float(beta / max(alpha, 1e-30))
